[
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "38133b22-1086-44e3-a693-bea195c34415",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC001-Chat Bubble Rendering and Toggle",
    "description": "Verify that the floating chat bubble appears correctly on the web page and toggles the expandable chat window with smooth animations when clicked.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the floating chat bubble to expand the chat window.\n        frame = context.pages[-1]\n        # Click the floating chat bubble to toggle the chat window open\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the floating chat bubble again to collapse the chat window.\n        frame = context.pages[-1]\n        # Click the floating chat bubble again to toggle the chat window closed\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Perform a final visual check to confirm the smoothness of the toggle animations and then conclude the task.\n        frame = context.pages[-1]\n        # Click the floating chat bubble to expand the chat window again for final visual check of animation smoothness\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=CallWaiting').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Log In').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign Up Free').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real voice • Instant replies').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Never Miss Another Call').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Your 24/7 AI Receptionist').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Powered by ODIADEV AI TTS — featuring voices Marcus, Marcy, Austyn & Joslyn.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Try Live Demo (+14156876510)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=No credit card required • Setup in 48 hours • Human-like voice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=See How It Works').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Watch AI answer a real customer call in seconds').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Live Demo: +1 (218) 400-3410').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=This is a real demonstration of CallWaiting AI answering a customer call. The AI responds instantly with natural, human-like speech powered by ODIADEV technology.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Try it yourself - Call our demo AI now').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Call +14156876510').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Free demo • No signup required • Available 24/7').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Always-On Answering').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI responds instantly—even outside work hours or when you're in a meeting.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Talks Like a Human').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Realistic voice. Understands intent. No IVR menu nonsense.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Captures Leads, Not Just Calls').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Collects key info and passes it straight to your WhatsApp or CRM.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Live Demo Available').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hear It For Yourself').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Call Ada, our AI receptionist. She'll answer your questions about CallWaiting AI in real-time. No appointment needed.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Example Conversation:').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hi, I'm interested in your AI service. How does it work?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Thanks for calling! CallWaiting AI is a voice assistant that answers calls when you can't. It speaks naturally, captures lead information, and integrates with your existing tools. Would you like to know about pricing or setup time?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Call +14156876510').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Get Your AI Now').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Available 24/7 • Average wait time: 0 seconds').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TRUSTED BY').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logo 1').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logo 2').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logo 3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Logo 4').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Ready to Never Miss Another Call?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Join hundreds of businesses already using CallWaiting AI. Start your free trial today and experience the future of call handling.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=5 Minutes Free').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test our AI with no commitment. See how it works with your actual calls.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=48-Hour Setup').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=We configure everything for you. Just provide your phone number and preferences.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial Now').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=No credit card required • 5 minutes free • Setup in 48 hours').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pay Only for What You Use').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Simple pricing that grows with you').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Let AI answer your calls — only pay for what you use. Starter plans begin at just $20.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Starter').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Small creators / trial users').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$20').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$0.17/min').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=120 voice minutes included').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Up to 120 AI call minutes').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1 business line').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI voice demo + webhook setup').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Basic analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Email support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=24/7 AI availability').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Try free • Pay only when you're ready').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=MOST POPULAR').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pro').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Growing e-commerce stores').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$80').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$0.14/min').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=600 voice minutes included').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Up to 600 AI call minutes').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Multi-channel support (TikTok, WhatsApp)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Custom voice tone & personality').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Email reports + real-time dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Priority support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Advanced analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Try free • Pay only when you're ready').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Enterprise').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Agencies / large call volumes').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$180').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=/month').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=$0.11/min').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2,000 voice minutes included').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2,000+ AI call minutes').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Priority support').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Custom integrations & branding').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dedicated voice model').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=API access').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Volume discounts available').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Try free • Pay only when you're ready').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Custom').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Integrators & enterprises').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Contact us').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Custom AI receptionist').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bulk deployment').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dedicated account manager').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=White-label options').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=SLA guarantees').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Custom development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Schedule Call').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=How it works: Sign up → Test your AI for free → Choose a plan → Pay for minutes → Your AI goes live 24/7').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Unused minutes roll over monthly • Cancel anytime • No hidden fees').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Need help deciding? Contact our team or ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=call Ada at +1 (415) 687-6510').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Frequently Asked Questions').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What happens when someone calls?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Your AI picks up instantly, speaks naturally, answers questions, and captures important details like name, callback number, and what they need. You get a summary via WhatsApp or email.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Does it really sound human?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Yes. Try calling our demo line at +1 (415) 687-6510 to hear it yourself. Most people can't tell it's AI.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What if the AI doesn't know the answer?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=It takes a message and lets the caller know you'll follow up. You can customize responses for common questions during setup.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=How long does setup take?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Most businesses are live within 48 hours. We handle the technical setup—you just provide your FAQs and business info.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Can it schedule appointments?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Yes. It integrates with calendar tools and can book appointments based on your availability.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What about privacy and security?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=All conversations are encrypted. We're GDPR compliant and don't share your data with third parties.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CallWaiting').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pricing').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=FAQ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Contact').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2025 CallWaiting AI. All rights reserved.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Powered by ODIADEV AI TTS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Start Free Trial').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ODIADEV Assistant').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Always here to help').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hi! I'm your CallWaitingAI assistant. How can I help you today? 😊').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Test Admin Panel').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TEST MODE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Admin Password').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Create Test Account').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760830052236609//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.451Z",
    "modified": "2025-10-18T23:27:32.531Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "2063df58-6c7c-4ee4-bcc0-d814c8f3f7b4",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC002-Text Chat Input and AI Response",
    "description": "Check that the text input accepts user messages, triggers AI response generation via webhook, and displays the AI text reply with a loading indicator.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the chat window from the chat bubble.\n        frame = context.pages[-1]\n        # Open the chat window from the chat bubble.\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the other chat bubble button (index 16) labeled 'Get Help' to see if it opens the chat window.\n        frame = context.pages[-1]\n        # Click the 'Get Help' button to try opening the chat window.\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI Response Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The chat input did not accept user messages, the AI response was not triggered or displayed, or the loading indicator did not appear as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The chat window failed to open after clicking the chat bubble buttons, blocking further testing of the AI chat input and response features. Issue reported for resolution.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/page.js:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <ServerRoot> component:\n\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nConsider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829774148726//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.456Z",
    "modified": "2025-10-18T23:22:54.333Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "f226fa6f-7b53-48ca-aef5-33ffde69aa36",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC003-Voice Chat Mode Activation and Microphone Permission",
    "description": "Validate that the voice chat mode activates microphone access properly and shows visual recording timer upon starting voice input.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the chat window by clicking the chat button at bottom right.\n        frame = context.pages[-1]\n        # Click the 'Chat with us' button to open the chat window.\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Microphone access granted and recording started')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The voice chat mode did not activate microphone access properly or the visual recording timer did not appear as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue that the chat window does not open after clicking the chat button, preventing further testing of voice chat mode. Stopping the test here.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829729479884//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.462Z",
    "modified": "2025-10-18T23:22:09.656Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "2bac565c-2a7f-43cd-950e-1d6122273ea7",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC004-Voice Recording, Sending and AI Response with Audio Playback",
    "description": "Test full flow of recording a voice message, sending it via the webhook, receiving AI text and audio response, and automatic playback of audio.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice message sent successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The full flow of recording a voice message, sending it via webhook, receiving AI text and audio response, and automatic playback did not complete successfully as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/animations/ai-demo.mp4:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/176082972518742//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.468Z",
    "modified": "2025-10-18T23:22:05.354Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "5169bf2f-ce9a-4444-a277-75e236343db6",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC005-Webhook Valid JSON Response Validation",
    "description": "Ensure that the configured n8n cloud webhook returns valid JSON responses containing both required 'text' and 'audio_url' fields for given valid inputs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Send a test POST request with a valid text payload to the webhook URL.\n        await page.goto('http://localhost:3000/api/webhook', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Return to main page or dashboard to locate correct webhook URL or instructions.\n        frame = context.pages[-1]\n        # Click Create Test Account button to access test admin panel for possible webhook info\n        elem = frame.locator('xpath=html/body/section[2]/div/div/div[3]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin password and create test account to access admin panel for webhook info.\n        frame = context.pages[-1]\n        # Input admin password in test admin panel\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click Create Test Account button\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Webhook response contains valid JSON with text and audio_url fields').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The webhook did not return a valid JSON response containing both 'text' and 'audio_url' fields as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The webhook URL cannot be accessed because the admin password for the test admin panel is invalid. No alternative webhook URL or instructions are visible on the main page or demo sections. Therefore, I cannot send test POST requests or verify the webhook responses. Please provide the correct admin password or the webhook URL to continue testing.\nBrowser Console Logs:\n[WARNING] [Fast Refresh] performing full reload\n\nFast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\nYou might have a file which exports a React component but also exports a value that is imported by a non-React component file.\nConsider migrating the non-React component export to a separate file and importing it into both files.\n\nIt is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\nFast Refresh requires at least one parent function component in your React tree. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:112:24)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/api/webhook:0:0)\n[ERROR] Warning: Extra attributes from the server: %s%s style \n    at input\n    at div\n    at div\n    at div\n    at TestAdminPanel (webpack-internal:///(app-pages-browser)/./components/TestAdminPanel.tsx:19:11)\n    at body\n    at html\n    at RootLayout (Server)\n    at RedirectErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:74:9)\n    at RedirectBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:82:11)\n    at NotFoundErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:76:9)\n    at NotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:84:11)\n    at DevRootNotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-not-found-boundary.js:33:11)\n    at ReactDevOverlay (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js:87:9)\n    at HotReload (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:321:11)\n    at Router (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:207:11)\n    at ErrorBoundaryHandler (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:113:9)\n    at ErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:160:11)\n    at AppRouter (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:585:13)\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11) (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] Failed to load resource: the server responded with a status of 401 (Unauthorized) (at http://localhost:3000/api/admin/test-create:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829909809484//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.475Z",
    "modified": "2025-10-18T23:25:09.983Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "23440795-21a6-4ead-9e26-91bd05724220",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC006-Error Handling and User Feedback on Webhook Failures",
    "description": "Verify that the chat widget correctly displays user-friendly error messages and logs debug information when errors occur during webhook calls or AI/TTS processing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the chat widget to prepare for webhook error simulation.\n        frame = context.pages[-1]\n        # Click the 'Chat with us' button to open the chat widget\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Webhook call succeeded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The chat widget did not display the expected user-friendly error messages or log debug information during webhook or TTS API failures as outlined in the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to chat widget not opening on user interaction, which is critical for verifying error handling. Reported the issue for developer attention.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/page.js:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829823460237//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.480Z",
    "modified": "2025-10-18T23:23:43.641Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "1cf4a718-2a3b-4cde-96ef-47874b996c32",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC007-UI Responsiveness and Accessibility",
    "description": "Test that the chat widget UI components (bubble, chat window, buttons, timers, text input) render and function correctly across different viewport sizes and support accessibility standards.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-10-18T23:17:10.485Z",
    "modified": "2025-10-18T23:17:10.485Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "5b8bbffa-560d-4aa5-93d2-ddf4a304fd77",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC008-Import and Validation of Ready n8n Workflows",
    "description": "Verify that all provided n8n workflows (simple echo test, full AI + TTS, production optimizations) import into n8n cloud without errors and respond correctly to test payloads.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Log in or create test account to access n8n cloud or admin panel for importing workflows.\n        frame = context.pages[-1]\n        # Enter admin password in test admin panel\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testpassword')\n        \n\n        frame = context.pages[-1]\n        # Click Create Test Account button to log in for testing\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Workflow Import Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The n8n workflows did not import or deploy correctly in n8n cloud as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to log in or create test account. The 'Create Test Account' button does not respond or change the page after entering the admin password. Unable to proceed with workflow import and testing. Please fix the login issue to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/animations/ai-demo.mp4:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <NotFoundErrorBoundary> component:\n\n    at Lazy\n    at body\n    at html\n    at RootLayout (Server)\n    at RedirectErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:74:9)\n    at RedirectBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:82:11)\n    at NotFoundErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:76:9)\n    at NotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:84:11)\n    at DevRootNotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-not-found-boundary.js:33:11)\n    at ReactDevOverlay (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js:87:9)\n    at HotReload (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:321:11)\n    at Router (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:207:11)\n    at ErrorBoundaryHandler (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:113:9)\n    at ErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:160:11)\n    at AppRouter (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:585:13)\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nReact will try to recreate this component tree from scratch using the error boundary you provided, ReactDevOverlay. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829843433307//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.491Z",
    "modified": "2025-10-18T23:24:03.613Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "57e5ed6c-8596-456b-93ed-2871b79ca2b0",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC009-Security Practices Enforcement",
    "description": "Validate that API key management, environment variable usage, CORS restrictions, HTTPS enforcement, and rate limiting are implemented as per security requirements.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Confirm environment variables are used for sensitive information by checking server environment or configuration files if accessible, or by inspecting deployment settings.\n        frame = context.pages[-1]\n        # Click 'Create Test Account' to access admin or test environment for further inspection of environment variables usage\n        elem = frame.locator('xpath=html/body/div[5]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=API Key Exposed in Client Code').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: API key management, environment variable usage, CORS restrictions, HTTPS enforcement, and rate limiting are not properly implemented as per security requirements.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Security validation halted. The 'Create Test Account' button is non-functional and prevents further testing of environment variable usage and other security features. Please fix this issue to proceed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/animations/ai-demo.mp4:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <NotFoundErrorBoundary> component:\n\n    at Lazy\n    at body\n    at html\n    at RootLayout (Server)\n    at RedirectErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:74:9)\n    at RedirectBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:82:11)\n    at NotFoundErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:76:9)\n    at NotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:84:11)\n    at DevRootNotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-not-found-boundary.js:33:11)\n    at ReactDevOverlay (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js:87:9)\n    at HotReload (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:321:11)\n    at Router (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:207:11)\n    at ErrorBoundaryHandler (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:113:9)\n    at ErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:160:11)\n    at AppRouter (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:585:13)\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nReact will try to recreate this component tree from scratch using the error boundary you provided, ReactDevOverlay. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829798776732//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.497Z",
    "modified": "2025-10-18T23:23:19.028Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "ac3cb53c-4c2a-41e3-811e-600dbd05b351",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC010-Performance Testing of AI Response Time",
    "description": "Ensure that AI responses are generated and returned within 3 seconds under typical load to meet performance requirements.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Chat with us' button to open the chat widget for testing AI chat response times.\n        frame = context.pages[-1]\n        # Click the 'Chat with us' button to open the chat widget for testing AI chat response times.\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the chat widget icon at index 16 to fully expand the chat input area or find the correct input field for text input.\n        frame = context.pages[-1]\n        # Click chat widget icon to expand chat input area for text input.\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI response time exceeded 3 seconds').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: AI responses did not meet the performance requirement of returning within 3 seconds under typical load.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inaccessible chat input field in the chat widget. Cannot proceed with performance testing of AI responses. Issue reported for developer investigation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/animations/ai-demo.mp4:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <NotFoundErrorBoundary> component:\n\n    at Lazy\n    at body\n    at html\n    at RootLayout (Server)\n    at RedirectErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:74:9)\n    at RedirectBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:82:11)\n    at NotFoundErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:76:9)\n    at NotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:84:11)\n    at DevRootNotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-not-found-boundary.js:33:11)\n    at ReactDevOverlay (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js:87:9)\n    at HotReload (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:321:11)\n    at Router (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:207:11)\n    at ErrorBoundaryHandler (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:113:9)\n    at ErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:160:11)\n    at AppRouter (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:585:13)\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nReact will try to recreate this component tree from scratch using the error boundary you provided, ReactDevOverlay. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829737853001//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.502Z",
    "modified": "2025-10-18T23:22:18.031Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "f4d6d487-7866-4a1a-970c-669d6e4d9765",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC011-Documentation Completeness and Accuracy",
    "description": "Confirm that comprehensive documentation is available covering setup, troubleshooting, deployment, and testing of the CallWaiting AI Chat Widget.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and open the setup guide or documentation link for installation, configuration, and environment requirements.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Click the FAQ link to review documentation content for setup guide.\n        frame = context.pages[-1]\n        # Click FAQ link to open documentation\n        elem = frame.locator('xpath=html/body/footer/div/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down or explore the page to find detailed setup guide or documentation link.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Check the main navigation or footer for a dedicated 'Documentation', 'Support', or 'Contact' link that might lead to detailed guides.\n        frame = context.pages[-1]\n        # Click Contact link to check if it leads to documentation or support resources\n        elem = frame.locator('xpath=html/body/footer/div/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Comprehensive Setup and Troubleshooting Guide for CallWaiting AI').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The documentation does not contain a comprehensive setup, troubleshooting, deployment, and testing guide for the CallWaiting AI Chat Widget as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Comprehensive documentation covering setup, troubleshooting, deployment, and testing of the CallWaiting AI Chat Widget is not accessible on the website. The FAQ section provides only summary information, and attempts to access Contact or support pages did not reveal detailed guides. Task is stopped due to lack of available documentation.\nBrowser Console Logs:\n[ERROR] An unknown error occurred when fetching the script. (at :0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/_next/webpack-hmr' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/use-websocket.js:41:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829915046944//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.508Z",
    "modified": "2025-10-18T23:25:15.245Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "daa49915-9411-4c8b-80db-4b29b2d72ef8",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC012-Multi-turn Conversation Continuity",
    "description": "Validate that the chat widget maintains conversation context across multiple user inputs and AI responses for coherent multi-turn dialogs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the chat widget by clicking the chat button to start conversation.\n        frame = context.pages[-1]\n        # Click the chat widget button to open chat interface\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send an initial message via the chat input field.\n        frame = context.pages[-1]\n        # Send initial message to chat widget input field\n        elem = frame.locator('xpath=html/body/div[3]/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Hello, can you tell me about your AI receptionist features?')\n        \n\n        frame = context.pages[-1]\n        # Click the send button to submit the initial message\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send a follow-up message referring to the AI's previous response to test if the AI maintains conversation context.\n        frame = context.pages[-1]\n        # Send follow-up message referring to previous AI response about agent configuration\n        elem = frame.locator('xpath=html/body/div[4]/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Can you explain how the agent configuration works?')\n        \n\n        frame = context.pages[-1]\n        # Click send button to submit follow-up message\n        elem = frame.locator('xpath=html/body/div[4]/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry sending a follow-up message or test another follow-up to verify if the AI can maintain context or if the error persists.\n        frame = context.pages[-1]\n        # Retry sending follow-up message about agent configuration due to previous error\n        elem = frame.locator('xpath=html/body/div[4]/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Could you please provide details on agent configuration again?')\n        \n\n        frame = context.pages[-1]\n        # Click send button to submit retry follow-up message\n        elem = frame.locator('xpath=html/body/div[4]/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Conversation context lost or unrelated answer detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The chat widget did not maintain conversation context across multiple user inputs and AI responses, resulting in incoherent multi-turn dialogs.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The chat widget was tested for maintaining conversation context across multiple user inputs and AI responses. Initial message received a relevant response, but subsequent follow-up messages about agent configuration resulted in repeated connection error messages from the AI assistant. This indicates the chat widget does not maintain conversation context properly in multi-turn dialogs. Test concluded with failure to maintain context.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/support/assistant:0:0)\n[ERROR] Error sending message: Error: Failed to get response\n    at sendMessage (webpack-internal:///(app-pages-browser)/./components/support/float-chat.tsx:61:23) (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/support/assistant:0:0)\n[ERROR] Error sending message: Error: Failed to get response\n    at sendMessage (webpack-internal:///(app-pages-browser)/./components/support/float-chat.tsx:61:23) (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829870289325//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.519Z",
    "modified": "2025-10-18T23:24:30.505Z"
  },
  {
    "projectId": "7389d2a4-fadc-488e-aec0-f2d549097a47",
    "testId": "6a988a2e-5383-478b-819f-a12d64807886",
    "userId": "a45814b8-e041-7012-a697-1f99c1fb1b87",
    "title": "TC013-Audio Playback Configuration Testing",
    "description": "Verify that the MiniMax TTS female voice is correctly configured and that auto-playback of AI audio responses works with proper volume and clarity settings.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the chat button to open the chat widget and send a chat message to trigger an audio response.\n        frame = context.pages[-1]\n        # Click on the 'Chat with us' button to open the chat widget\n        elem = frame.locator('xpath=html/body/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll or explore the page to find the correct chat input field and send a chat message to trigger audio response.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Scroll down further to reveal the chat input field and send button, then send a chat message to trigger the audio response.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Click the chat widget toggle button in the bottom right corner to open the chat input field and send a chat message to trigger audio response.\n        frame = context.pages[-1]\n        # Click the chat widget toggle button in the bottom right corner to open chat input field\n        elem = frame.locator('xpath=html/body/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=MiniMax TTS male voice activated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The MiniMax TTS female voice is not correctly configured or audio playback did not occur as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical runtime error preventing chat widget interaction and audio response testing. The MiniMax TTS female voice and auto-playback verification could not be completed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/layout.js:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/animations/ai-demo.mp4:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <NotFoundErrorBoundary> component:\n\n    at Lazy\n    at body\n    at html\n    at RootLayout (Server)\n    at RedirectErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:74:9)\n    at RedirectBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js:82:11)\n    at NotFoundErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:76:9)\n    at NotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js:84:11)\n    at DevRootNotFoundBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-not-found-boundary.js:33:11)\n    at ReactDevOverlay (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/ReactDevOverlay.js:87:9)\n    at HotReload (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/react-dev-overlay/app/hot-reloader-client.js:321:11)\n    at Router (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:207:11)\n    at ErrorBoundaryHandler (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:113:9)\n    at ErrorBoundary (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js:160:11)\n    at AppRouter (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js:585:13)\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nReact will try to recreate this component tree from scratch using the error boundary you provided, ReactDevOverlay. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a45814b8-e041-7012-a697-1f99c1fb1b87/1760829798255604//tmp/test_task/result.webm",
    "created": "2025-10-18T23:17:10.525Z",
    "modified": "2025-10-18T23:23:18.444Z"
  }
]
